// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const addPodMember = `-- name: AddPodMember :one

INSERT INTO pod_members (
  user_id,
  pod_id
) VALUES (
  $1, $2
) RETURNING id, user_id, pod_id, joined_at
`

type AddPodMemberParams struct {
	UserID int64 `json:"user_id"`
	PodID  int64 `json:"pod_id"`
}

// Pod Member Queries
func (q *Queries) AddPodMember(ctx context.Context, arg AddPodMemberParams) (PodMember, error) {
	row := q.db.QueryRow(ctx, addPodMember, arg.UserID, arg.PodID)
	var i PodMember
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PodID,
		&i.JoinedAt,
	)
	return i, err
}

const checkUserInPod = `-- name: CheckUserInPod :one
SELECT EXISTS (
  SELECT 1 FROM pod_members
  WHERE user_id = $1 AND pod_id = $2
)
`

type CheckUserInPodParams struct {
	UserID int64 `json:"user_id"`
	PodID  int64 `json:"pod_id"`
}

func (q *Queries) CheckUserInPod(ctx context.Context, arg CheckUserInPodParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserInPod, arg.UserID, arg.PodID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createBean = `-- name: CreateBean :one

INSERT INTO beans (
  pod_id,
  name
) VALUES (
  $1, $2
) RETURNING id, pod_id, name, created_at
`

type CreateBeanParams struct {
	PodID int64  `json:"pod_id"`
	Name  string `json:"name"`
}

// Bean Queries
func (q *Queries) CreateBean(ctx context.Context, arg CreateBeanParams) (Bean, error) {
	row := q.db.QueryRow(ctx, createBean, arg.PodID, arg.Name)
	var i Bean
	err := row.Scan(
		&i.ID,
		&i.PodID,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const createMessage = `-- name: CreateMessage :one

WITH new_message AS (
  INSERT INTO messages (
    id,
    bean_id,
    author_id,
    content
  ) VALUES (
    $1, $2, $3, $4
  ) RETURNING id, bean_id, author_id, content, created_at, updated_at
)
SELECT
  m.id, m.bean_id, m.author_id, m.content, m.created_at, m.updated_at,
  u.username as author_username,
  u.avatar_url as author_avatar_url,
  u.user_color as author_user_color,
  u.id as author_id,
  b.pod_id as pod_id,
  b.name as bean_name
FROM new_message m
JOIN users u ON m.author_id = u.id
JOIN beans b ON m.bean_id = b.id
`

type CreateMessageParams struct {
	ID       string `json:"id"`
	BeanID   int64  `json:"bean_id"`
	AuthorID int64  `json:"author_id"`
	Content  string `json:"content"`
}

type CreateMessageRow struct {
	ID              string      `json:"id"`
	BeanID          int64       `json:"bean_id"`
	AuthorID        int64       `json:"author_id"`
	Content         string      `json:"content"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       *time.Time  `json:"updated_at"`
	AuthorUsername  string      `json:"author_username"`
	AuthorAvatarUrl pgtype.Text `json:"author_avatar_url"`
	AuthorUserColor string      `json:"author_user_color"`
	AuthorID_2      int64       `json:"author_id_2"`
	PodID           int64       `json:"pod_id"`
	BeanName        string      `json:"bean_name"`
}

// Message Queries
func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (CreateMessageRow, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.ID,
		arg.BeanID,
		arg.AuthorID,
		arg.Content,
	)
	var i CreateMessageRow
	err := row.Scan(
		&i.ID,
		&i.BeanID,
		&i.AuthorID,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuthorUsername,
		&i.AuthorAvatarUrl,
		&i.AuthorUserColor,
		&i.AuthorID_2,
		&i.PodID,
		&i.BeanName,
	)
	return i, err
}

const createPod = `-- name: CreatePod :one

INSERT INTO pods (
  owner_id,
  name,
  invite_code
) VALUES (
  $1, $2, $3
) RETURNING id, owner_id, name, invite_code, created_at
`

type CreatePodParams struct {
	OwnerID    int64       `json:"owner_id"`
	Name       string      `json:"name"`
	InviteCode pgtype.Text `json:"invite_code"`
}

// Pod Queries
func (q *Queries) CreatePod(ctx context.Context, arg CreatePodParams) (Pod, error) {
	row := q.db.QueryRow(ctx, createPod, arg.OwnerID, arg.Name, arg.InviteCode)
	var i Pod
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.InviteCode,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (
  username,
  email,
  auth_id,
  avatar_url,
  user_color
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING id, username, email, auth_id, avatar_url, created_at, user_color
`

type CreateUserParams struct {
	Username  string      `json:"username"`
	Email     string      `json:"email"`
	AuthID    string      `json:"auth_id"`
	AvatarUrl pgtype.Text `json:"avatar_url"`
	UserColor string      `json:"user_color"`
}

// User Queries
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.Email,
		arg.AuthID,
		arg.AvatarUrl,
		arg.UserColor,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.AuthID,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UserColor,
	)
	return i, err
}

const deleteBean = `-- name: DeleteBean :exec
DELETE FROM beans
WHERE id = $1
`

func (q *Queries) DeleteBean(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteBean, id)
	return err
}

const deleteMessage = `-- name: DeleteMessage :exec
DELETE FROM messages
WHERE id = $1
`

func (q *Queries) DeleteMessage(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteMessage, id)
	return err
}

const deletePod = `-- name: DeletePod :exec
DELETE FROM pods
WHERE id = $1
`

func (q *Queries) DeletePod(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePod, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getBean = `-- name: GetBean :one
SELECT id, pod_id, name, created_at FROM beans
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetBean(ctx context.Context, id int64) (Bean, error) {
	row := q.db.QueryRow(ctx, getBean, id)
	var i Bean
	err := row.Scan(
		&i.ID,
		&i.PodID,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const getMessage = `-- name: GetMessage :one
SELECT id, bean_id, author_id, content, created_at, updated_at FROM messages
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetMessage(ctx context.Context, id string) (Message, error) {
	row := q.db.QueryRow(ctx, getMessage, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.BeanID,
		&i.AuthorID,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPod = `-- name: GetPod :one
SELECT id, owner_id, name, invite_code, created_at FROM pods
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetPod(ctx context.Context, id int64) (Pod, error) {
	row := q.db.QueryRow(ctx, getPod, id)
	var i Pod
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.InviteCode,
		&i.CreatedAt,
	)
	return i, err
}

const getPodByInviteCode = `-- name: GetPodByInviteCode :one
SELECT id, owner_id, name, invite_code, created_at FROM pods
WHERE invite_code = $1 LIMIT 1
`

func (q *Queries) GetPodByInviteCode(ctx context.Context, inviteCode pgtype.Text) (Pod, error) {
	row := q.db.QueryRow(ctx, getPodByInviteCode, inviteCode)
	var i Pod
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.InviteCode,
		&i.CreatedAt,
	)
	return i, err
}

const getPodMember = `-- name: GetPodMember :one
SELECT id, user_id, pod_id, joined_at FROM pod_members
WHERE user_id = $1 AND pod_id = $2
`

type GetPodMemberParams struct {
	UserID int64 `json:"user_id"`
	PodID  int64 `json:"pod_id"`
}

func (q *Queries) GetPodMember(ctx context.Context, arg GetPodMemberParams) (PodMember, error) {
	row := q.db.QueryRow(ctx, getPodMember, arg.UserID, arg.PodID)
	var i PodMember
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PodID,
		&i.JoinedAt,
	)
	return i, err
}

const getUserByAuthID = `-- name: GetUserByAuthID :one
SELECT id, username, email, auth_id, avatar_url, created_at, user_color FROM users
WHERE auth_id = $1 LIMIT 1
`

func (q *Queries) GetUserByAuthID(ctx context.Context, authID string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByAuthID, authID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.AuthID,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UserColor,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, auth_id, avatar_url, created_at, user_color FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.AuthID,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UserColor,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email, auth_id, avatar_url, created_at, user_color FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.AuthID,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UserColor,
	)
	return i, err
}

const listBeansForPod = `-- name: ListBeansForPod :many
SELECT id, pod_id, name, created_at FROM beans
WHERE pod_id = $1
ORDER BY name
`

func (q *Queries) ListBeansForPod(ctx context.Context, podID int64) ([]Bean, error) {
	rows, err := q.db.Query(ctx, listBeansForPod, podID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bean{}
	for rows.Next() {
		var i Bean
		if err := rows.Scan(
			&i.ID,
			&i.PodID,
			&i.Name,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBeansForPodFull = `-- name: ListBeansForPodFull :many
SELECT
    b.id,
    b.name,
    p.id as pod_id,
    p.name as pod_name,
    COALESCE(jsonb_agg(
        json_build_object(
            'id', m.id,
            'content', m.content,
            'created_at', m.created_at,
            'author_id', u.id,
            'author_username', u.username,
            'author_avatar_url', u.avatar_url,
            'author_user_color', u.user_color
        ) ORDER BY m.created_at ASC
    ) FILTER (WHERE m.id IS NOT NULL), '[]'::jsonb) as messages
FROM beans b
JOIN pods p ON b.pod_id = p.id
LEFT JOIN messages m ON m.bean_id = b.id
LEFT JOIN users u ON m.author_id = u.id
WHERE b.pod_id = $1
GROUP BY b.id, p.id, p.name
ORDER BY b.name
`

type ListBeansForPodFullRow struct {
	ID       int64       `json:"id"`
	Name     string      `json:"name"`
	PodID    int64       `json:"pod_id"`
	PodName  string      `json:"pod_name"`
	Messages interface{} `json:"messages"`
}

func (q *Queries) ListBeansForPodFull(ctx context.Context, podID int64) ([]ListBeansForPodFullRow, error) {
	rows, err := q.db.Query(ctx, listBeansForPodFull, podID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBeansForPodFullRow{}
	for rows.Next() {
		var i ListBeansForPodFullRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PodID,
			&i.PodName,
			&i.Messages,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesInBean = `-- name: ListMessagesInBean :many
SELECT m.id, m.bean_id, m.author_id, m.content, m.created_at, m.updated_at, u.username as author_username, u.id as author_id FROM messages m
JOIN users u ON m.author_id = u.id
WHERE bean_id = $1
ORDER BY m.created_at
LIMIT 50
`

type ListMessagesInBeanRow struct {
	ID             string     `json:"id"`
	BeanID         int64      `json:"bean_id"`
	AuthorID       int64      `json:"author_id"`
	Content        string     `json:"content"`
	CreatedAt      time.Time  `json:"created_at"`
	UpdatedAt      *time.Time `json:"updated_at"`
	AuthorUsername string     `json:"author_username"`
	AuthorID_2     int64      `json:"author_id_2"`
}

func (q *Queries) ListMessagesInBean(ctx context.Context, beanID int64) ([]ListMessagesInBeanRow, error) {
	rows, err := q.db.Query(ctx, listMessagesInBean, beanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMessagesInBeanRow{}
	for rows.Next() {
		var i ListMessagesInBeanRow
		if err := rows.Scan(
			&i.ID,
			&i.BeanID,
			&i.AuthorID,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorUsername,
			&i.AuthorID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPodMembers = `-- name: ListPodMembers :many
SELECT id, user_id, pod_id, joined_at FROM pod_members
WHERE pod_id = $1
`

func (q *Queries) ListPodMembers(ctx context.Context, podID int64) ([]PodMember, error) {
	rows, err := q.db.Query(ctx, listPodMembers, podID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PodMember{}
	for rows.Next() {
		var i PodMember
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PodID,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPodsForUser = `-- name: ListPodsForUser :many
SELECT p.id, p.owner_id, p.name, p.invite_code, p.created_at FROM pods p
JOIN pod_members pm ON p.id = pm.pod_id
WHERE pm.user_id = $1
`

func (q *Queries) ListPodsForUser(ctx context.Context, userID int64) ([]Pod, error) {
	rows, err := q.db.Query(ctx, listPodsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Pod{}
	for rows.Next() {
		var i Pod
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.InviteCode,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removePodMember = `-- name: RemovePodMember :exec
DELETE FROM pod_members
WHERE user_id = $1 AND pod_id = $2
`

type RemovePodMemberParams struct {
	UserID int64 `json:"user_id"`
	PodID  int64 `json:"pod_id"`
}

func (q *Queries) RemovePodMember(ctx context.Context, arg RemovePodMemberParams) error {
	_, err := q.db.Exec(ctx, removePodMember, arg.UserID, arg.PodID)
	return err
}

const updateBean = `-- name: UpdateBean :one
UPDATE beans
SET
  name = $1
WHERE id = $2
RETURNING id, pod_id, name, created_at
`

type UpdateBeanParams struct {
	Name string `json:"name"`
	ID   int64  `json:"id"`
}

func (q *Queries) UpdateBean(ctx context.Context, arg UpdateBeanParams) (Bean, error) {
	row := q.db.QueryRow(ctx, updateBean, arg.Name, arg.ID)
	var i Bean
	err := row.Scan(
		&i.ID,
		&i.PodID,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const updateMessage = `-- name: UpdateMessage :one
WITH updated_message AS (
  UPDATE messages
  SET
    content = $2,
    updated_at = now()
  WHERE messages.id = $1
  RETURNING id, bean_id, author_id, content, created_at, updated_at
)
SELECT
  um.id,
  um.bean_id,
  um.author_id,
  um.content,
  um.created_at,
  um.updated_at,
  b.pod_id,
  b.name as bean_name,
  u.username as author_username,
  u.avatar_url as author_avatar_url,
  u.user_color as author_user_color,
  u.id as author_id
FROM updated_message um
JOIN beans b on um.bean_id = b.id
JOIN users u ON um.author_id = u.id
`

type UpdateMessageParams struct {
	ID      string `json:"id"`
	Content string `json:"content"`
}

type UpdateMessageRow struct {
	ID              string      `json:"id"`
	BeanID          int64       `json:"bean_id"`
	AuthorID        int64       `json:"author_id"`
	Content         string      `json:"content"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       *time.Time  `json:"updated_at"`
	PodID           int64       `json:"pod_id"`
	BeanName        string      `json:"bean_name"`
	AuthorUsername  string      `json:"author_username"`
	AuthorAvatarUrl pgtype.Text `json:"author_avatar_url"`
	AuthorUserColor string      `json:"author_user_color"`
	AuthorID_2      int64       `json:"author_id_2"`
}

func (q *Queries) UpdateMessage(ctx context.Context, arg UpdateMessageParams) (UpdateMessageRow, error) {
	row := q.db.QueryRow(ctx, updateMessage, arg.ID, arg.Content)
	var i UpdateMessageRow
	err := row.Scan(
		&i.ID,
		&i.BeanID,
		&i.AuthorID,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PodID,
		&i.BeanName,
		&i.AuthorUsername,
		&i.AuthorAvatarUrl,
		&i.AuthorUserColor,
		&i.AuthorID_2,
	)
	return i, err
}

const updatePod = `-- name: UpdatePod :one
UPDATE pods
SET
  name = $1,
  invite_code = $2
WHERE id = $3
RETURNING id, owner_id, name, invite_code, created_at
`

type UpdatePodParams struct {
	Name       string      `json:"name"`
	InviteCode pgtype.Text `json:"invite_code"`
	ID         int64       `json:"id"`
}

func (q *Queries) UpdatePod(ctx context.Context, arg UpdatePodParams) (Pod, error) {
	row := q.db.QueryRow(ctx, updatePod, arg.Name, arg.InviteCode, arg.ID)
	var i Pod
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.InviteCode,
		&i.CreatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET
  username = $1,
  avatar_url = $2
WHERE id = $3
RETURNING id, username, email, auth_id, avatar_url, created_at, user_color
`

type UpdateUserParams struct {
	Username  string      `json:"username"`
	AvatarUrl pgtype.Text `json:"avatar_url"`
	ID        int64       `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser, arg.Username, arg.AvatarUrl, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.AuthID,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UserColor,
	)
	return i, err
}
